// Generated by CoffeeScript 1.6.3
(function() {
  var GameObject, Projectile, Ship,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.SpaceDom || (window.SpaceDom = {});

  GameObject = window.SpaceDom.GameObject;

  Projectile = window.SpaceDom.Projectile;

  window.SpaceDom.Ship = Ship = (function(_super) {
    __extends(Ship, _super);

    Ship.prototype.hud = true;

    function Ship(image, game, proto) {
      var key, value, weapon, _i, _len, _ref, _ref1, _ref2;
      this.image = image;
      this.game = game;
      this.proto = proto;
      Ship.__super__.constructor.call(this, this.image, this.game, this.proto.specs);
      this.status = {
        curhp: 0,
        maxhp: 0,
        hregen: 0,
        shield: 0,
        maxshield: 0,
        sregen: 0,
        armor: 0,
        weapons: [],
        curweapon: -1
      };
      _ref = this.specs;
      for (key in _ref) {
        value = _ref[key];
        this.status[key] = value;
      }
      _ref1 = this.proto.specs;
      for (key in _ref1) {
        value = _ref1[key];
        this.status[key] = value;
      }
      if (this.proto.weapons != null) {
        _ref2 = this.proto.weapons;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          weapon = _ref2[_i];
          this.status.weapons.push(weapon);
        }
      }
      this.status.curweapon = 0;
      this.particle_timer = 0;
    }

    Ship.prototype.canFire = function() {
      var wp;
      if (this.status.curweapon < 0 || this.status.curweapon >= this.status.weapons.length) {
        false;
      }
      wp = this.status.weapons[this.status.curweapon];
      return wp.curammo >= wp.points.length && wp.firetimer <= 0;
    };

    Ship.prototype.fire = function() {
      var angle, cos, offset, offsetXY, point, proj, projectiles, sin, wp;
      if (!this.canFire()) {
        return;
      }
      angle = this.rotation * Math.PI / 180;
      cos = Math.cos(angle);
      sin = Math.sin(angle);
      offsetXY = {
        x: 0,
        y: 0
      };
      offset = {
        angle: 0,
        mag: 0
      };
      wp = this.status.weapons[this.status.curweapon];
      projectiles = (function() {
        var _i, _len, _ref, _results;
        _ref = wp.points;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          proj = new Projectile(this.game.preload.getResult(wp.image), this.game, wp.projectile, this);
          offsetXY.x = point.x - this.regX;
          offsetXY.y = point.y - this.regY;
          offset.angle = Math.atan2(offsetXY.y, offsetXY.x);
          offset.mag = Math.sqrt(offsetXY.x * offsetXY.x + offsetXY.y * offsetXY.y);
          proj.x = this.x + offset.mag * Math.cos(offset.angle + angle);
          proj.y = this.y + offset.mag * Math.sin(offset.angle + angle);
          proj.vel.x = wp.projectile.initvel * cos;
          proj.vel.y = wp.projectile.initvel * sin;
          proj.accel.x = wp.projectile.accel * cos;
          proj.accel.y = wp.projectile.accel * sin;
          proj.rotation = this.rotation;
          this.game.addObject(proj);
          _results.push(wp.curammo--);
        }
        return _results;
      }).call(this);
      return wp.firetimer = wp.firerate;
    };

    Ship.prototype.update = function(delta) {
      var angle, offset, offsetXY, particle, point, wp, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      Ship.__super__.update.call(this, delta);
      if (this.status.curhp <= 0) {
        this.isRemove = true;
        if (((_ref = this.proto.destroyed) != null ? _ref.particle : void 0) != null) {
          particle = new SpaceDom.Particle(this.proto.destroyed.particle, this.game);
          particle.x = this.x;
          particle.y = this.y;
          this.game.addParticle(particle);
        }
      }
      this.particle_timer -= delta;
      if (this.particle_timer <= 0 && (this.accel.x !== 0 || this.accel.y !== 0) && (this.proto.engine != null)) {
        _ref1 = this.proto.engine.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          point = _ref1[_i];
          particle = new SpaceDom.Particle(this.proto.engine.particle, this.game);
          offsetXY = {
            x: point.x - this.regX,
            y: point.y - this.regY
          };
          offset = {
            angle: 0,
            mag: 0
          };
          offset.angle = Math.atan2(offsetXY.y, offsetXY.x);
          offset.mag = Math.sqrt(offsetXY.x * offsetXY.x + offsetXY.y * offsetXY.y);
          angle = this.rotation * Math.PI / 180;
          particle.x = this.x + offset.mag * Math.cos(offset.angle + angle);
          particle.y = this.y + offset.mag * Math.sin(offset.angle + angle);
          this.game.addParticle(particle);
        }
        this.particle_timer = 0.1;
      }
      _ref2 = this.status.weapons;
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        wp = _ref2[_j];
        if (wp.firetimer > 0) {
          wp.firetimer -= delta;
          if (wp.firetimer <= 0) {
            wp.firetimer = 0;
          }
        }
        wp.regentimer -= delta;
        if (wp.regentimer <= 0) {
          wp.regentimer = wp.regen;
          wp.curammo++;
          if (wp.curammo > wp.maxammo) {
            _results.push(wp.curammo = wp.maxammo);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Ship.prototype.canCollide = function(other) {
      return Ship.__super__.canCollide.call(this, other);
    };

    Ship.prototype.collide = function(other) {
      return Ship.__super__.collide.call(this, other);
    };

    Ship.prototype.takeDamage = function(other) {
      var particle;
      if (other instanceof Ship) {
        return console.log('collide ship');
      } else if (other instanceof Projectile) {
        this.status.shield -= other.specs.damage;
        if (this.status.shield < 0) {
          this.status.curhp += this.status.shield;
          this.status.shield = 0;
          particle = new SpaceDom.Particle(other.specs['hull'].particle || 'hull-hit', this.game);
        } else {
          particle = new SpaceDom.Particle(other.specs['shield'].particle || other.specs['hull'] || 'hull-hit', this.game);
        }
        if (particle != null) {
          particle.x = other.x;
          particle.y = other.y;
          return this.game.addParticle(particle);
        }
      }
    };

    return Ship;

  })(GameObject);

}).call(this);

/*
//@ sourceMappingURL=Ship.map
*/
