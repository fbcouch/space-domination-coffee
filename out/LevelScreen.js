// Generated by CoffeeScript 1.6.3
(function() {
  var LevelScreen,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.SpaceDom || (window.SpaceDom = {});

  window.SpaceDom.LevelScreen = LevelScreen = (function(_super) {
    __extends(LevelScreen, _super);

    function LevelScreen(preload, game, level_id) {
      this.preload = preload;
      this.game = game;
      this.level_id = level_id;
      this.unpause = __bind(this.unpause, this);
      this.pause = __bind(this.pause, this);
      LevelScreen.__super__.constructor.call(this, this.preload, this.game);
      this.gameObjects = [];
      this.particles = [];
      this.level = this.preload.getResult(this.level_id);
      this.shiplist = this.preload.getResult('shiplist');
      this.gameState = '';
    }

    LevelScreen.prototype.show = function() {
      var menu, menuItems, _ref,
        _this = this;
      this.levelGroup = new createjs.Container();
      this.backgroundGroup = new createjs.Container();
      this.foregroundGroup = new createjs.Container();
      this.gameObjGroup = new createjs.Container();
      this.HUD = new SpaceDom.HUD(this);
      this.levelGroup.addChild(this.backgroundGroup);
      this.levelGroup.addChild(this.gameObjGroup);
      this.levelGroup.addChild(this.foregroundGroup);
      this.levelGroup.addChild(this.HUD);
      this.addChild(this.levelGroup);
      menuItems = [
        {
          text: 'Continue',
          action: 'unpause'
        }, {
          text: 'Quit',
          action: 'quit'
        }
      ];
      this._pauseMenu = new SpaceDom.UpdateContainer();
      this._pauseMenuTitle = new createjs.Text("PAUSED", "bold 40px Arial", "#3366FF");
      this._pauseMenu.addChild(this._pauseMenuTitle);
      menu = new SpaceDom.TextMenu(menuItems, null, function(item) {
        switch (item.action) {
          case 'quit':
            return _this.game.setMenuScreen();
          case 'unpause':
            if (_this.gameState === 'paused') {
              return _this.unpause();
            } else {
              return _this.game.setScreen(new LevelScreen(_this.preload, _this.game, _this.level_id));
            }
        }
      });
      this._pauseMenu.addChild(menu);
      menu.y = 50;
      _ref = this._pauseMenu.getBounds(), this._pauseMenu.width = _ref.width, this._pauseMenu.height = _ref.height;
      this._pauseMenuTitle.textAlign = 'center';
      this._pauseMenuTitle.x = this._pauseMenu.width * 0.5;
      menu.x = (this._pauseMenu.width - menu.width) * 0.5;
      this._pauseMenu.x = (this.width - this._pauseMenu.width) * 0.5;
      this._pauseMenu.y = (this.height - this._pauseMenu.height) * 0.5;
      this.generateLevel();
      return this.pause();
    };

    LevelScreen.prototype.resize = function(width, height) {
      this.width = width;
      this.height = height;
      if (this.backgroundGroup != null) {
        this.backgroundGroup.removeAllChildren();
        return this.generateBackground();
      }
    };

    LevelScreen.prototype.update = function(delta, keys) {
      var angle, key, obj, other, particle, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      LevelScreen.__super__.update.call(this, delta, keys);
      if (this.first_pass_done == null) {
        this.first_pass_done = true;
        for (key in keys) {
          keys[key] = false;
        }
      }
      switch (this.gameState) {
        case 'paused':
          this._pauseMenu.update(delta, keys);
          if (keys.pause) {
            if (!this.pause_key_down) {
              this.unpause();
            }
            this.pause_key_down = true;
          } else {
            this.pause_key_down = false;
          }
          break;
        case 'running':
          if (keys.left && !keys.right) {
            this.player.rotate(delta, true);
          } else if (keys.right && !keys.left) {
            this.player.rotate(delta);
          }
          if (keys.accel && !keys.brake) {
            this.player.thrust(delta);
          } else if (keys.brake && !keys.accel && (this.player.vel.x !== 0 || this.player.vel.y !== 0)) {
            this.player.thrust(delta, true);
          } else {
            this.player.accel.x = this.player.accel.y = 0;
          }
          if (keys.fire) {
            this.player.fire();
          }
          if (keys.pause) {
            if (!this.pause_key_down) {
              this.pause();
            }
            this.pause_key_down = true;
          } else {
            this.pause_key_down = false;
          }
          _ref = this.gameObjects;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            obj = _ref[_i];
            obj.vel.x += obj.accel.x * delta;
            obj.vel.y += obj.accel.y * delta;
            if (obj.specs.vel * obj.specs.vel < obj.vel.x * obj.vel.x + obj.vel.y * obj.vel.y) {
              angle = Math.atan2(obj.vel.y, obj.vel.x);
              obj.vel.x = obj.specs.vel * Math.cos(angle);
              obj.vel.y = obj.specs.vel * Math.sin(angle);
            }
            obj.x += obj.vel.x * delta;
            obj.y += obj.vel.y * delta;
            obj.update(delta);
            if (obj.isRemove) {
              continue;
            }
            _ref1 = this.gameObjects.slice(this.gameObjects.indexOf(obj) + 1);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              other = _ref1[_j];
              if (!other.isRemove) {
                if ((typeof obj.canCollide === "function" ? obj.canCollide(other) : void 0) && (typeof other.canCollide === "function" ? other.canCollide(obj) : void 0) && SpaceDom.GameObject.collideRect(obj, other) && ndgmr.checkPixelCollision(obj.image, other.image, 0, false)) {
                  obj.collide(other);
                  other.collide(obj);
                }
              }
            }
          }
          _ref2 = this.gameObjects;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            obj = _ref2[_k];
            if (obj != null ? obj.isRemove : void 0) {
              this.removeObject(obj);
            }
          }
          _ref3 = this.particles;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            particle = _ref3[_l];
            if (particle != null ? particle.isComplete() : void 0) {
              this.removeParticle(particle);
            }
          }
          if (this.player.isRemove) {
            this._pauseMenuTitle.text = "DEFEAT";
            this.addChild(this._pauseMenu);
            this.gameState = 'gameover';
          }
          if (((function() {
            var _len4, _m, _ref4, _results;
            _ref4 = this.gameObjects;
            _results = [];
            for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
              obj = _ref4[_m];
              if (obj instanceof SpaceDom.Ship && obj !== this.player && !obj.isRemove) {
                _results.push(obj);
              }
            }
            return _results;
          }).call(this)).length === 0) {
            this._pauseMenuTitle.text = "VICTORY";
            this.addChild(this._pauseMenu);
            this.gameState = 'gameover';
          }
          break;
        case 'gameover':
          this._pauseMenu.update(delta, keys);
      }
      this.levelGroup.x = this.width * 0.5 - this.player.x;
      this.levelGroup.y = this.height * 0.5 - this.player.y;
      this.backgroundGroup.x = (Math.floor(this.player.x / 512) - Math.floor(this.backgroundGroup.width / 512 * 0.5)) * 512;
      this.backgroundGroup.y = (Math.floor(this.player.y / 512) - Math.floor(this.backgroundGroup.height / 512 * 0.5)) * 512;
      return this.HUD.update();
    };

    LevelScreen.prototype.addObject = function(obj) {
      if (__indexOf.call(this.gameObjects, obj) < 0) {
        this.gameObjects.push(obj);
      }
      return this.gameObjGroup.addChild(obj);
    };

    LevelScreen.prototype.removeObject = function(obj) {
      if (__indexOf.call(this.gameObjects, obj) >= 0) {
        this.gameObjects.splice(this.gameObjects.indexOf(obj), 1);
      }
      return this.gameObjGroup.removeChild(obj);
    };

    LevelScreen.prototype.addParticle = function(particle) {
      this.particles.push(particle);
      return this.foregroundGroup.addChild(particle);
    };

    LevelScreen.prototype.removeParticle = function(particle) {
      if (__indexOf.call(this.particles, particle) >= 0) {
        this.particles.splice(this.particles.indexOf(particle), 1);
      }
      return this.foregroundGroup.removeChild(particle);
    };

    LevelScreen.prototype.generateBackground = function() {
      var bg, bgobj, x, y, _i, _ref, _results;
      bg = this.preload.getResult(this.level.background.image || 'bg-starfield-sparse');
      _results = [];
      for (y = _i = 0, _ref = Math.floor(this.height / bg.height) + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = Math.floor(this.width / bg.width) + 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            bgobj = new createjs.Bitmap(bg);
            bgobj.x = bgobj.image.width * x;
            bgobj.y = bgobj.image.height * y;
            this.backgroundGroup.addChild(bgobj);
            this.backgroundGroup.width = bgobj.x + bgobj.image.width;
            _results1.push(this.backgroundGroup.height = bgobj.y + bgobj.image.height);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    LevelScreen.prototype.generateLevel = function() {
      var ship, spawn, _i, _len, _ref;
      _ref = this.level.spawns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spawn = _ref[_i];
        if (spawn.id === 'player') {
          ship = this.player = new SpaceDom.Ship(this.preload.getResult(this.shiplist['base-fighter'].image), this, this.shiplist['base-fighter']);
        } else {
          ship = new SpaceDom.AIShip(this.preload.getResult(this.shiplist[spawn.id].image), this, this.shiplist[spawn.id]);
        }
        ship.x = spawn.x || 0;
        ship.y = spawn.y || 0;
        ship.rotation = spawn.r || 0;
        this.addObject(ship);
      }
      return this.generateBackground();
    };

    LevelScreen.prototype.pause = function() {
      this.addChild(this._pauseMenu);
      return this.gameState = 'paused';
    };

    LevelScreen.prototype.unpause = function() {
      this.removeChild(this._pauseMenu);
      return this.gameState = 'running';
    };

    return LevelScreen;

  })(SpaceDom.Screen);

}).call(this);

/*
//@ sourceMappingURL=LevelScreen.map
*/
