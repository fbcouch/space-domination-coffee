// Generated by CoffeeScript 1.6.3
(function() {
  var GameObject,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.SpaceDom || (window.SpaceDom = {});

  window.SpaceDom.GameObject = GameObject = (function(_super) {
    __extends(GameObject, _super);

    GameObject.prototype.isRemove = false;

    GameObject.prototype.hud = false;

    function GameObject(image, game, specs) {
      var key, value;
      this.game = game;
      this.initialize();
      this.image = new createjs.Bitmap(image);
      this.addChild(this.image);
      this.width = this.image.image.width;
      this.height = this.image.image.height;
      this.regX = this.width / 2;
      this.regY = this.height / 2;
      this.vel = {
        x: 0,
        y: 0
      };
      this.accel = {
        x: 0,
        y: 0
      };
      this.collideRect = {
        x: 0,
        y: 0,
        w: this.width,
        h: this.height
      };
      this.specs = {
        accel: 0,
        brake: 0,
        vel: 0,
        rotate: 0
      };
      for (key in specs) {
        value = specs[key];
        this.specs[key] = value;
      }
      this.particle_timer = 0;
    }

    GameObject.prototype.update = function(delta) {
      var angle, offset, offsetXY, particle, point, _i, _len, _ref;
      this.particle_timer -= delta;
      if (this.particle_timer <= 0 && (this.accel.x !== 0 || this.accel.y !== 0) && (this.engine != null)) {
        _ref = this.engine.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          particle = new SpaceDom.Particle(this.engine.particle, this.game);
          offsetXY = {
            x: point.x - this.regX,
            y: point.y - this.regY
          };
          offset = {
            angle: 0,
            mag: 0
          };
          offset.angle = Math.atan2(offsetXY.y, offsetXY.x);
          offset.mag = Math.sqrt(offsetXY.x * offsetXY.x + offsetXY.y * offsetXY.y);
          angle = this.rotation * Math.PI / 180;
          particle.x = this.x + offset.mag * Math.cos(offset.angle + angle);
          particle.y = this.y + offset.mag * Math.sin(offset.angle + angle);
          this.game.addParticle(particle);
        }
        return this.particle_timer = 0.1;
      }
    };

    GameObject.prototype.canCollide = function(other) {
      return true;
    };

    GameObject.prototype.collide = function(other) {};

    GameObject.prototype.thrust = function(delta, brake) {
      var angle;
      if (brake) {
        angle = Math.atan2(this.vel.y, this.vel.x);
        this.accel.x = -1 * this.specs.brake * Math.cos(angle);
        this.accel.y = -1 * this.specs.brake * Math.sin(angle);
        if (Math.abs(this.accel.x * delta) >= Math.abs(this.vel.x)) {
          this.accel.x = this.vel.x = 0;
        }
        if (Math.abs(this.accel.y * delta) >= Math.abs(this.vel.y)) {
          return this.accel.y = this.vel.y = 0;
        }
      } else {
        this.accel.x = this.specs.accel * Math.cos(this.rotation * SpaceDom.DEG_TO_RAD);
        return this.accel.y = this.specs.accel * Math.sin(this.rotation * SpaceDom.DEG_TO_RAD);
      }
    };

    GameObject.prototype.rotate = function(delta, left) {
      this.rotation += (left ? -1 : 1) * this.specs.rotate * delta;
      if (this.rotation > 360) {
        this.rotation -= 360;
      }
      if (this.rotation < 0) {
        return this.rotation += 360;
      }
    };

    GameObject.collideRect = function(obj1, obj2) {
      var obj1rect, obj2rect, point, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      obj2rect = [obj2.localToLocal(obj2.collideRect.x, obj2.collideRect.y, obj1), obj2.localToLocal(obj2.collideRect.x + obj2.collideRect.w, obj2.collideRect.y, obj1), obj2.localToLocal(obj2.collideRect.x, obj2.collideRect.y + obj2.collideRect.h, obj1), obj2.localToLocal(obj2.collideRect.x + obj2.collideRect.w, obj2.collideRect.y + obj2.collideRect.h, obj1)];
      for (_i = 0, _len = obj2rect.length; _i < _len; _i++) {
        point = obj2rect[_i];
        if ((obj1.collideRect.x <= (_ref = point.x) && _ref <= obj1.collideRect.x + obj1.collideRect.w) && (obj1.collideRect.y <= (_ref1 = point.y) && _ref1 <= obj1.collideRect.y + obj1.collideRect.h)) {
          return true;
        }
      }
      obj1rect = [obj1.localToLocal(obj1.collideRect.x, obj1.collideRect.y, obj2), obj1.localToLocal(obj1.collideRect.x + obj1.collideRect.w, obj1.collideRect.y, obj2), obj1.localToLocal(obj1.collideRect.x, obj1.collideRect.y + obj1.collideRect.h, obj2), obj1.localToLocal(obj1.collideRect.x + obj1.collideRect.w, obj1.collideRect.y + obj1.collideRect.h, obj2)];
      for (_j = 0, _len1 = obj1rect.length; _j < _len1; _j++) {
        point = obj1rect[_j];
        if ((obj2.collideRect.x <= (_ref2 = point.x) && _ref2 <= obj2.collideRect.x + obj2.collideRect.w) && (obj2.collideRect.y <= (_ref3 = point.y) && _ref3 <= obj2.collideRect.y + obj2.collideRect.h)) {
          return true;
        }
      }
      return false;
    };

    return GameObject;

  })(createjs.Container);

}).call(this);

/*
//@ sourceMappingURL=GameObject.map
*/
